Overview

GrayServer manages:

A control TLS connection to a managing server.

Separate TCP ports for client and data connections.

A pool of preallocated sockets to minimize connection latency.

Asynchronous traffic forwarding between paired sockets.

OTP-based connection validation for security.

Self-managed shutdown using a ServerManager.

It is designed for high concurrency, reliability, and minimal delay.

Server Creation

A GrayServer instance is created using std::make_shared:

auto server = std::make_shared<GrayServer>(
    server_id,
    control_socket,
    io_context,
    data_port,
    client_port,
    pool_size,
    manager
);


server_id — unique server identifier.

control_socket — TLS socket for server management.

io_context — Asio context for asynchronous operations.

data_port, client_port — ports for data and client connections.

pool_size — number of sockets maintained in the client pool. Larger pools allow more concurrent users with minimal latency.

manager — ServerManager instance used for self-destruction: after calling shutdown(), the server notifies the manager to remove its reference. Full destruction occurs when the last shared_ptr reference disappears.

Start the server with:

server->start();


This initializes acceptors, starts asynchronous socket acceptance, runs the data pool check, and schedules ping checks.

Connection Handling
Data Connections

Handled by async_accept_data().

Each data socket is accepted one at a time, validated with OTP, and added to the data pool.

A timer (data_pool_timer) ensures the pool check occurs safely, allowing for delayed OTP arrival.

If OTP validation fails or socket is closed, the connection is terminated.

The method is recursively called to continuously accept new connections.

Client Connections

Handled by async_accept_client().

Each new client socket is added to the client_pool.

Once a client and a data socket are available, they are paired using try_create_pair().

OTP Validation

Each data socket must provide a one-time password (OTP) generated by the server.

OTP is sent to the managing server via the control TLS connection.

If the OTP does not match, the connection is closed.

Ensures secure and validated data connections.

Data Pool Management

check_data_pool() periodically scans data_pool to remove closed or invalid sockets.

If the pool has fewer sockets than pool_size, a new OTP is generated and sent to the managing server.

Timer ensures repeated checks; if a socket hasn’t yet sent OTP, it will be retried safely in the next cycle.

Socket Pairing

try_create_pair() matches one client socket with one data socket.

Generates a unique pair_id.

Adds the pair to link_pool and starts splice_loop() to forward data between the two sockets asynchronously.

Supports multiple concurrent pairs with minimal delay.

Ping/Pong Liveness Check

ping_timer sends periodic pings to the managing server.

pong_timer waits for responses.

If no pong is received within the timeout (ping_timeout_sec), the server automatically calls shutdown().

Ensures the server remains responsive and detects network failures or disconnects.

Shutdown Procedure

Cancels all timers (ping_timer, pong_timer, data_pool_timer).

Closes acceptors and all open sockets.

Removes all active socket pairs.

Notifies ServerManager to remove the server instance, allowing for safe self-destruction.\